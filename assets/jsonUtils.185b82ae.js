import{em as m,en as c,eo as p,ep as C,c7 as f,eq as $,er as I,j as u,bS as d,es as L,dM as w,et as h,s as y,bU as x,bT as k,eu as D,bV as v,bW as g,ev as F,ew as T,ex as U,ey as V}from"./index.7eb0daf2.js";import{S as W,u as z,c as E}from"./defaults.e5a1167a.js";import{e as P,i as j}from"./defaultsJSON.ba72df2f.js";m.fromSimpleMarkerSymbol(W);c.fromSimpleLineSymbol(z);p.fromSimpleFillSymbol(E);new C({symbolLayers:new f([new $({material:{color:P},edges:new I({size:u(1),color:new d(j)})})])});const q=new c({symbolLayers:new f([new L({material:{color:new d([0,0,0])},size:u(1)})])}),A=new p({symbolLayers:new f([new $({outline:{color:new d([0,0,0]),size:u(1)}})])}),i={retainId:!1,ignoreDrivers:!1,hasLabelingContext:!0};function B(e,n=i){if(!e)return{symbol:null};const{retainId:r=i.retainId,ignoreDrivers:s=i.ignoreDrivers,hasLabelingContext:l=i.hasLabelingContext,retainCIM:t=i.retainCIM,cimFallbackEnabled:a=i.cimFallbackEnabled}=n;let o=null;if(w(e)||e instanceof h)o=e.clone();else if(e.type==="cim"){const b=e.data?.symbol?.type;switch(b){case"CIMPointSymbol":o=t?e.clone():m.fromCIMSymbol(e);break;case"CIMLineSymbol":a&&(o=q.clone(),n?.logWarning?.("Unsupported CIM line symbology converted to fallback 3D line symbology"));break;case"CIMPolygonSymbol":a&&(o=A.clone(),n?.logWarning?.("Unsupported CIM polygon symbology converted to fallback 3D polygon symbology"))}if(!o)return{error:new y("symbol-conversion:unsupported-cim-symbol",`CIM symbol of type '${b||"unknown"}' is unsupported in 3D`,{symbol:e})}}else if(e instanceof x)o=c.fromSimpleLineSymbol(e);else if(e instanceof k)o=m.fromSimpleMarkerSymbol(e);else if(e instanceof D)o=m.fromPictureMarkerSymbol(e);else if(e instanceof v)o=n.geometryType&&n.geometryType==="mesh"?C.fromSimpleFillSymbol(e):p.fromSimpleFillSymbol(e);else{if(!(e instanceof g))return{error:new y("symbol-conversion:unsupported-2d-symbol",`2D symbol of type '${e.type||e.declaredClass}' is unsupported in 3D`,{symbol:e})};o=l?F.fromTextSymbol(e):m.fromTextSymbol(e)}return r&&o&&o.type!=="cim"&&(o.id=e.id),s&&w(o)&&o.symbolLayers.forEach(b=>b.ignoreDrivers=!0),{symbol:o}}function K(e,n,r,s){const l=M(e,{},{context:s,isLabelSymbol:!1});l!=null&&(n[r]=l)}function N(e,n,r,s){const l=M(e,{},{context:s,isLabelSymbol:!0});l!=null&&(n[r]=l)}function S(e){return e instanceof V||e instanceof h}function M(e,n,r){if(e==null)return null;const{context:s,isLabelSymbol:l}=r,t=s?.origin,a=s?.messages;if(t==="web-scene"&&!S(e)){const o=B(e,{retainCIM:!0,hasLabelingContext:l});return o.symbol!=null?o.symbol.write(n,s):(a?.push(new y("symbol:unsupported",`Symbols of type '${e.declaredClass}' are not supported in scenes. Use 3D symbology instead when working with WebScene and SceneView`,{symbol:e,context:s,error:o.error})),null)}return(t==="web-map"||t==="portal-item"&&!T(s?.layer))&&S(e)?(a?.push(new y("symbol:unsupported",`Symbols of type '${e.declaredClass}' are not supported in web maps and portal items. Use 2D symbology and CIMSymbol instead when working with MapView`,{symbol:e,context:s})),null):e.write(n,s)}function O(e,n){return U(e,null,n)}export{O as b,N as i,K as l};
